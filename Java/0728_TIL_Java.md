### 목차

- [1. JAVA](#1-java)
  * [1. Java란](#1-java란)
    + [1-1. Java 언어의 특징](#1-1-java-언어의-특징)
    + [1-2. JVM (Java Virtural Machine)](#1-2-jvm-java-virtural-machine)
    + [1-3. 자바 개발 환경](#1-3-자바-개발-환경)
  * [2. 출력메소드와 리터럴](#2-출력메소드와-리터럴)
    + [2-1. 출력메소드](#2-1-출력메소드)
    + [2-2. 리터럴](#2-2-리터럴)
  * [3. 연산](#3-연산)
  * [4. 변수(Variable)](#4-변수variable)
  * [5. 자료형(Type)](#5-자료형type)
  * [6. 데이터 저장 단위](#6-데이터-저장-단위)
    + [기타](#기타)



# 1. JAVA

## 1. Java란

### 1-1. Java 언어의 특징

- 컴퓨터가 이해할 수 있도록 번역하는 것이 compile
- 운영체제에 독립적 (이식성 우수)
  - JVM(Java Virtural Machine)을 사용하면 운영체제와 상관없이 동작을 가능하게 한다.
- 다른 언어의 단점(포인터, 메모리관리)을 보완하여 상대적으로 사용하기 쉽다.
  - C언어의 경우 프로그래머가 직접 메모리를 할당하고 회수해야 한다.
- 풍부한 오픈소스 와 멀티쓰레드 환경을 제공한다.

### 1-2. JVM (Java Virtural Machine)

- 자바를 실행하기 위한 가상 기계로 플랫폼에 의존적이다.
- byte code(class 파일)를 해석하고 실행하는 interpreter
- 작성한 코드 → compile → JVM이 이해할 수 있는 코드 → 운영체제가 이해할 수 있는 코드

### 1-3. 자바 개발 환경

- JRE (Java Runtime Environment)
  - Java Class LIbrary(API)
  - 프로그램을 실행하는데 필요함
- JDK (Java Development Kit)
  - Utilities
  - 개발을 하는데 필요함
  - compiler의 개념을 포함하고 있음
- Java SE : java Standard Edition
- Java EE : Java Enterprise Edition
  - 서버까지 동작할 수 있고 웹개발을 위해 필요
- Java Me : Java Micro Edition
  - 기기들에 들어가는 경우



## 2. 출력메소드와 리터럴

### 2-1. 출력메소드

- System.out.print()
  - 변수, 문자, 숫자, 논리값을 모니터에 출력해주는 메소드
  - 줄 바꿈 없이 출력한다.
- System.out.println()
  - 출력 후 자동으로 줄 바꿈을 해준다.

```java
/* 1. 문자형태의 값 출력 시 주의 사항 */
//System.out.println('ab');      //두 개 이상은 문자로 취급하지 않기 때문에 에러가 발생한다.
//System.out.println('');        //아무 문자도 기록되지 않은 경우도 에러가 발생한다.

System.out.println("");	         //아무 값도 없는 빈 쌍따옴표도 문자열로 취급한다.
System.out.println("a");         //한 개의 문자를 쌍따옴표로 감싸면 문자열이다. (문자 a와는 다르다)
```

### 2-2. 리터럴

- 프로그래밍 언어에서 미리 정의해놓은 값의 형태를 말한다. (리터럴 종류에 따라 사용할 수 있는 연산자가 다름)
- 숫자(정수, 실수), 문자(알파벳하나, 'A'), 문자열("안녕하세요"), 논리(true)



## 3. 연산

- 리터럴 값들을 직접 산술 연산할 수 있다.
- 리터럴 종류별 사용 불가능한 산술 연산이 존재하기 때문에 에러가 발생할 수 있으므로 사용 시 주의하여야 한다.
- +, -, /, *, %
  - 정수와 정수의 연산에서는 나눴을 때 소수점은 표시하지 않음
  - 정수와 실수 연산의 결과는 항상 실수가 나온다
- 연산 규칙
  1. 숫자와 숫자의 연산
     - 정수끼리의 연산과 실수끼리의 연산에서 사칙연산과 추가로 mod 연산을 사용할 수 있다.
     - 정수와 실수의 연산에서도 사칙연산과 mod 연산을 사용할 수 있지만 해당 결과값은 항상 실수가 나온다.
  2. 문자의 연산
     - 문자와 문자의 연산과 문자와 정수의 연산 모두 사칙연산과 mod 연산이 가능하다.
     - 컴퓨터는 문자를 인식하지 못하고 숫자로만 인식할 수 있기 때문에 모든 문자에 대응되는 숫자들이 매칭되어 있다. (아스키코드)
     - 문자와 실수의 연산도 정수처럼 모든 연산이 가능하지만 결과값은 실수 형태로 나온다.
  3. 문자열의 연산
     - 문자열과 문자열의 연산에서는 '+'를 사용한 문자열 합치기(이어 붙이기)만 가능하다.
     - 문자열과 다른 형태의 값 연산에서도 마찬가지로 '+' 연산을 이용한 문자열 합치기만 가능하다.
  4. 논리값의 연산
     - 논리값끼리의 연산은 모든 연산자 사용이 불가능하다.
     - 논리값과 정수, 실수, 문자와의 연산에서 연산자 사용이 불가능하다.
     - 논리값과 문자열의 연산은 결국 문자열 합치기가 되는 원리와 동일하게 '+' 연산자만 사용할 수 있다.

```java
public class Application3 {

	public static void main(String[] args) {
		System.out.println(9 + 9);         //18
		System.out.println("9" + 9);       //99
		System.out.println(9 + "9");       //99
		System.out.println("9" + "9");     //99
        
		//'+'의 연산 방향은 왼쪽에서 오른쪽이다 (숫자부터 합쳐짐)
		System.out.println(9 + 9 + "9");   //189  
        
        // 왼쪽의 연산부터 수행하고 수행 결과를 오른쪽과 연산함
		System.out.println(9 + "9" + 9);   //999    
		System.out.println("9" + 9 + 9);   //999      
		
		System.out.println("9" + (9 + 9)); //918
	}
}
```



## 4. 변수(Variable)

- **메모리(RAM)에** 시간에 따라 변하는 값을 **기록**하기 위한 **공간**
- 변수의 사용 목적
  1. 값에 의미를 부여하기 위한 목적
     - 의미 전달이 쉬워야 코드를 읽기 쉬워지고, 협업 및 유지보수에 유리하기 때문이다.
  2. 한 번 저장해둔 값을 재사용하기 위한 목적
     - 변수를 이용하여 코드를 작성하면, 값을 변경할 때도 보다 간편하게 변경할 수 있기 때문이다.
  3. 시간에 따라 변하는 값을 저장하고 사용하기 위한 목적
     - 변하는 값을 저장하기 위한 공간으로서의 역할을 하기 때문이다.
- 변수를 선언하는 방법 : **자료형 변수명;**
- 변수를 사용하는 방법
  1. 변수를 준비한다. (선언)
  2. 변수에 값을 대입한다. (값 대입 및 초기화)
     - 값 대입
       - 변수를 선언하는 것은 메모리에 값을 저장하기 위해 공간만 생성해 둔 상태이다.
       - 그 공간에 대입연산자를 이용하여 자료형에 저장히기로 한 형태의 값을 저장할 수 있으며 약속 내용과 다른 형태의 값을 대입하려고 하면 Compiler는 에러를 발생시킨다.
       - 대입연산자의 실행 방향은 오름쪽에서 왼쪽이다.
         - 오른쪽에 있는 값을 왼쪽의 공간에 대입한다는 의미이며, 왼쪽에는 항상 공간, 오르쪽에는 항상 값이 온다.
     - 초기화
       - 변수를 선언하고 난 뒤 최초로 값이 대입되는 것을 초기화라고 한다.
       - **선언과 동시에 초기화** : 변수 선언과 값 대입을 동시에 수행하는 것을 말한다.
  3. 변수를 사용한다.

```java
public class Application2 {

	public static void main(String[] args) {
		
		/* 2-1. 정수를 취급하는 자료형에 값 대입 */
		bnum = 1;
		snum = 2;
		inum = 4;
		//lnum = 8;      //뒤에 대문자 L을 붙여야 한다. 
		lnum = 8L;       //소문자 'l'은 1과 혼선이 빚어질 수 있어 대문자로 하는 것을 권장
		
		/* 2-2. 실수를 취급하는 자료형에 값 대입 */
		//fnum = 4.0;
		fnum = 4.0f;     //실수 뒤에 'f'를 붙여야 한다. 소문자를 사용하는 것이 일반적
		dnum = 8.0;
		
		/* 2-3. 문자를 취급하는 자료형에 값 대입 */
		ch = 'a';
		ch = 97;		     //'a'는 97이라는 숫자 값을 가지므로 숫자로도 char에 저장 가능하다. 
		
		/* 2-4. 논리를 취급하는 자료형에 값 대입 */
		isTrue = true;
		isTrue = false;  //true 혹은 false 중 한 가지의 값만 사용 가능하다.
		
		/* 2-5. 문자열을 취급하는 자료형에 값 대입 */
		str = "a";
		
		/* 일반적으로 사용하는 값을 독특한 형태가 아닌 일반적인 형채로 사용할 수 있는 자료형을 
         * 대표 자료형이라고 하며
		 * 정수형은 int, 실수형은 double이 대표 자료형이다. 
		 * 정수의 경우 일상 생활에서 많이 사용되는 숫자의 범위는 
		 * byte, short로는 표현이 불가능한 경우가 많아
		 * 특수한 경우가 아니면 byte와 short는 잘 사용하지 않는다.
		 * 실수의 경우 정확도를 기준으로 4byte 자료형보다 8byte 자료형이 
		 * 더 정확한 실수를 표현할 수 있기 때문에 
		 * double을 대표 자료형으로 사용하고 float는 특수한 목적이 있는 경우에만 사용하게 된다. 
		 * */
		
		int point = 100;
		int bonus = 10;
		
		/* 3. 변수를 사용한다. */
		/* 3-1. 변수에 저장한 값 출력하기 */
		System.out.println("============변수에 저장된 값 출력=============");
		System.out.println("bnum의 값 : " + bnum);
		System.out.println("snum의 값 : " + snum);
		System.out.println("inum의 값 : " + inum);
		System.out.println("lnum의 값 : " + lnum);
		
		System.out.println("fnum의 값 : " + fnum);
		System.out.println("dnum의 값 : " + dnum);
		
		System.out.println("ch의 값 : " +  ch);
		
		System.out.println("isTrue의 값 : " + isTrue);
				
		System.out.println("str의 값 : " + str);
		
		/* 3-2. 변수를 이용해서 연산하기 */
		/* 변수에 저장 된 값을 이용해서 연산을 할 수도 있다. */
		System.out.println("포인트와 보너스의 합은? " + (point + bonus));
		
		/* 3-3. 대입 연산자의 왼쪽편과 오른쪽편에 사용하기*/
		/* 대입 연산자의 왼편에는 공간이라는 의미, 오른편에는 값이라는 의미가 있다.
		 * 따라서 point라는 공간에 point가 가지고 있는 값 + 100한 값을 대입하라는 의미이다. */
		
		point = point + 100;
		
		System.out.println("point = point + 100? " + point);
	}
	
}
```



## 5. 자료형(Type)

- 데이터의 크기와 형태에 맞게 여러가지 형태의 자료형이 존재 한다.

- 자료형 : 다양한 값의 형태별로 어느 정도 크기를 하나의 값으로 취급할 것인지 미리 Compiler와 약속한 키워드이다. 이러한 자료형은 **기본자료형(Primary type)**과 **참조자료형(Reference type)**으로 나누어진다.

- 기본 자료형은 크게 아래와 같이 분류된다.

  1. 불린(boolean)
     - boolean : 1byte
  2. 문자(character)
     - char : 2byte
  3. 정수(intiger)
     - byte : 1byte
     - short : 2byte
     - int : 4byte
     - long : 8byte
  4. 실수(floating-point-number)
     - float : 4byte
     - double : 8byte

  - float와 double은 표현할 수 있는 유효자리의 수가 다르다는 차이점이 있고 이로 인해 double이 상대적으로 더 정확한 값을 표시할 수 있다.

- 문자열을 취급하는 자료형으로는 String - 참조자료형(4byte)이 있다.



## 6. 데이터 저장 단위

- 저장 공간이 제한적이기 때문에 저장 크기에 대한 기준과 CPU가 데이터를 처리할 때 일정한 기준 필요하다.
- 비트(bit) : 컴퓨터가 나타내는 데이터의 저장 최소 단위로서 2진수 값 하나를 저장할 수 있는 메모리 공간을 의미한다.
- 바이트(byte) : 데이터 처리 또는 문자의 최소 단위로서 8개의 비트가 모여 하나의 바이트가 구성된다.

- int 를 주로 사용함
- 실수의 경우 3.141592를 저장할 때 0.3141592 * 10^1 으로 저장함
- float 와 double의 차이는 표현할 수 있는 유효자리 숫자에 있고 double 이 더 정확하다
- double이 실수형의 기본 자료형이라고 할 수 있다.

- 0 x 는 16진수라는 의미
- = 은 대입연산자라고 부름
  - 오른쪽에서 왼쪽으로 실행
  - 오른쪽에 있는 값을 왼쪽에 있는 공간, 변수에 대입
- lnum = 8L; 뒤에 대문자L을 함께 사용

- src 안에 package를 생성하여 파일명에 com.greedy.section01.literal 이라고 쓰면 하위 폴더로 생성됨
  - package explorer에서는 .을 찍은 대로 표시됨
  - package는 최소 3개의 상위 파일이 필요함
    - com.greedy.section01
- 빨간 줄 생기는 건 compile error 번역할 수 없음
- 명령이 끝나면 ; (세미콜론)을 붙여주어야 함

```java
public class Application1 {
	
	public static void main(String[] args) {
		System.out.println("안녕하세요");
	}
}
```



### 기타

- public static void main(String[] args) {} → 메인 메소드
- main 을 입력하고 ctrl + spacebar 를 사용하면 자동 완성을 할 수 있음
- syso 를 입력하고 ctrl + spacebar 를 사용하면 자동 완성을 할 수 있음
- 주석
  - // 한줄 주석
  - /* */ 연달아 작성 가능
- shift enter는 다음줄로 넘어갈 수 있음
- coding convention = 개발자들끼리의 약속
- 홑따옴표 안에는 비어있을 수 없지만 쌍따옴표 안에는 비어있어도 문자열로 인식한다
- 'a' 와 "a"는 같지 않다

